# Union-Find(Disjoint Set)
작성자 : 박수완

여러 개의 원소가 있을 때, 이 원소들이 어떤 그룹(집합)에 속해 있는지 효율적으로 관리하고, 두 그룹을 합치는 연산을 빠르게 처리할 수 있는 자료구조이다. 이 알고리즘은 그래프에서의 연결 요소나 네트워크 연결
문제등을 처리할 때 주로 사용된다.


# Union-Find 알고리즘의 주요 연산
---

1. Find(찾기): 주어진 원소가 어느 집합에 속해 있는지를 찾는다. 부모 노드를 반환하는 연산으로 해당 집합의 "루트"를 찾는다.
2. Union(합치기): 두 개의 원소가 속한 두 집합을 하나로 합친다. 두 집합의 루트를 찾아 같은 집합으로 연결하는 과정이다.

# Union-Find 알고리즘의 동작 예시
---

초기 상태 1, 2, 3, 4, 5가 각각 독립된 집합에 속해 있다고 가정한다. 각 원소는 스스로를 부모로 가진다.

1    2    3    4    5

Union(1, 2) 연산: 1과 2를 갑은 집합으로 합친다.

1 -- 2    3    4    5

Union(3, 4): 3과 4를 같은 집합으로 합친다

1 -- 2    3 -- 4    5

Find(1) 연산

1의 부모는 자기 자신이므로, Find(1)의 결과는 1이다.

Find(2) 연산

2의 부모는 1이므로, Find(2)의 결과는 1이다.(1과 2는 같은 집합에 속함)

Union(2, 4) 연산: 2와 4를 같은 집합으로 합친다. 이제 1, 2, 3, 4가 같은 집합에 속한다.

    1 -- 2

      |
      
    3 -- 4    5

Find(3) 연산

3의 부모는 4였으니, 이제 경로 압축을 통해 부모를 1로 바꾼다.

# 경로 압축을 통한 Union 최적화
---
1. Find 연산을 할 때, 각 노드를 루트에 직접 연결하여 트리의 깊이를 줄인다.
   
ex) Find(3)을 수행하면, 3부터 1까지의 경로를 거치며 3의 부모를 1로 바로 설정한다.

경로 압축을 하지 않을 시 최악의 경우 부모 노드를 찾는 데 O(N)까지 걸린다.

# 구현

```java

    private static void union(int a, int b) {
        int ap = findParent(a);
        int bp = findParent(b);
        if(ap != bp) parent[bp] = ap;
    }

    private static int findParent(int x) {
        if (x == parent[x]) return parent[x];
        else return parent[x] = findParent(parent[x]); // 경로 압축
    }

```
